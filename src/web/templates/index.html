<!DOCTYPE html>
<html lang="en" class="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon" href="/static/favicon.ico">
    <title>Telegram Archive</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment-timezone/0.5.43/moment-timezone-with-data-1970-2030.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Flatpickr for date picker -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #1e293b;
        }

        ::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }

        /* Message Bubbles */
        .message-bubble {
            display: inline-block;
            max-width: calc(100vw - 32px);
            /* 32px = padding lateral del contenedor */
            width: auto;
            word-wrap: break-word;
            overflow-wrap: anywhere;
            border-radius: 12px;
        }

        @media (min-width: 768px) {
            .message-bubble {
                max-width: 600px;
            }
        }

        body,
        #app,
        .flex-1 {
            max-width: 100vw;
            overflow-x: hidden;
        }

        .message-bubble img,
        .message-bubble video,
        .message-bubble audio,
        .message-bubble a,
        .message-bubble .media-wrapper {
            max-width: 100%;
            width: 100%;
            height: auto;
        }


        /* Date Separator */
        .date-separator {
            text-align: center;
            margin: 20px 0 10px 0;
        }

        .date-separator span {
            background-color: #334155;
            padding: 6px 16px;
            border-radius: 16px;
            font-size: 0.75rem;
            color: #94a3b8;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-block;
        }

        .date-separator span:hover {
            background-color: #475569;
            color: #cbd5e1;
        }

        /* Flatpickr dark theme customization */
        .flatpickr-calendar {
            background: #1e293b !important;
            border: 1px solid #475569 !important;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5) !important;
        }

        .flatpickr-months {
            background: #334155 !important;
            border-bottom: 1px solid #475569 !important;
        }

        .flatpickr-month {
            color: #e2e8f0 !important;
        }

        .flatpickr-weekdays {
            background: #334155 !important;
        }

        .flatpickr-weekday {
            color: #94a3b8 !important;
        }

        .flatpickr-day {
            color: #e2e8f0 !important;
        }

        .flatpickr-day:hover {
            background: #475569 !important;
            border-color: #475569 !important;
        }

        .flatpickr-day.selected {
            background: #3b82f6 !important;
            border-color: #3b82f6 !important;
        }

        .flatpickr-day.today {
            border-color: #60a5fa !important;
        }

        .flatpickr-day.today:hover {
            background: #475569 !important;
        }

        /* Scroll to Bottom Button */
        .scroll-to-bottom-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: #334155;
            border: 1px solid #475569;
            color: #e2e8f0;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }

        .scroll-to-bottom-btn:hover {
            background: #475569;
            transform: scale(1.05);
        }

        .scroll-to-bottom-btn svg {
            width: 24px;
            height: 24px;
        }

        /* Clickable Links */
        .message-text a {
            color: #60a5fa;
            text-decoration: underline;
        }

        .message-text a:hover {
            color: #93c5fd;
        }
        
        /* Album Grid Styles */
        .album-grid {
            max-width: 400px;
        }
        .album-grid .grid {
            border-radius: 12px;
            overflow: hidden;
        }
        .album-item {
            aspect-ratio: 1;
            min-height: 80px;
            max-height: 200px;
        }
        .album-item img,
        .album-item video {
            min-height: 100%;
        }
        /* 3-item album: make first item span 2 rows */
        .album-grid .grid-cols-2:has(.album-item:nth-child(3):last-child) .album-item:first-child {
            grid-row: span 2;
        }
    </style>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        tg: {
                            bg: '#0f172a',
                            sidebar: '#1e293b',
                            hover: '#334155',
                            active: '#2b5278',
                            text: '#e2e8f0',
                            muted: '#94a3b8',
                            own: '#2b5278',
                            other: '#182533',
                        }
                    }
                }
            }
        }
    </script>
</head>

<body class="bg-gradient-to-br from-blue-600 via-blue-700 to-blue-800 text-white h-screen overflow-hidden">
    <div id="app" class="w-full h-full">
        <!-- Login Page -->
        <div v-if="!isAuthenticated" class="w-full h-full flex items-center justify-center">
            <div
                class="bg-white/10 backdrop-blur-lg rounded-2xl shadow-2xl p-10 w-full max-w-md border border-white/20">
                <!-- Telegram Logo -->
                <div class="flex justify-center mb-6">
                    <div class="w-20 h-20 bg-white rounded-full flex items-center justify-center shadow-lg">
                        <i class="fab fa-telegram-plane text-5xl text-blue-500"></i>
                    </div>
                </div>

                <h1 class="text-3xl font-bold mb-2 text-center text-white">Telegram Archive</h1>
                <p class="text-sm text-blue-100 mb-8 text-center" v-if="authRequired">
                    Sign in to access your backup
                </p>
                <p class="text-sm text-blue-100 mb-8 text-center" v-else-if="authCheckFailed">
                    ‚ö†Ô∏è Could not verify authentication. Try opening in your browser instead of in-app.
                </p>
                <p class="text-sm text-blue-100 mb-8 text-center" v-else>
                    Authentication is disabled
                </p>

                <form @submit.prevent="performLogin" class="space-y-5" v-if="authRequired || authCheckFailed">
                    <div>
                        <label class="block text-sm font-medium mb-2 text-blue-100">Username</label>
                        <input v-model="loginForm.username" type="text" autocomplete="username"
                            placeholder="Enter your username"
                            class="w-full bg-white/20 backdrop-blur-sm text-white placeholder-blue-200 rounded-xl px-4 py-3 border border-white/30 focus:outline-none focus:ring-2 focus:ring-white/50 focus:border-white/50 transition">
                    </div>
                    <div>
                        <label class="block text-sm font-medium mb-2 text-blue-100">Password</label>
                        <input v-model="loginForm.password" type="password" autocomplete="current-password"
                            placeholder="Enter your password"
                            class="w-full bg-white/20 backdrop-blur-sm text-white placeholder-blue-200 rounded-xl px-4 py-3 border border-white/30 focus:outline-none focus:ring-2 focus:ring-white/50 focus:border-white/50 transition">
                    </div>
                    <p v-if="loginError" class="text-sm text-red-200 bg-red-500/20 rounded-lg p-2 text-center">{{
                        loginError }}</p>
                    <button type="submit" :disabled="loadingAuth"
                        class="w-full bg-white text-blue-600 hover:bg-blue-50 disabled:opacity-60 disabled:cursor-not-allowed rounded-xl py-3 font-semibold transition shadow-lg hover:shadow-xl">
                        {{ loadingAuth ? 'Signing in...' : 'Sign in' }}
                    </button>
                </form>
            </div>
        </div>

        <!-- Main App -->
        <div v-else class="flex w-full h-full bg-tg-bg">
            <!-- Sidebar - hidden on mobile when chat is selected -->
            <div class="bg-tg-sidebar flex flex-col border-r border-gray-700"
                :class="{'hidden md:flex': selectedChat, 'w-full md:w-1/4 md:min-w-[300px]': true}">
                <!-- Header with Stats Dropdown -->
                <div class="p-4 border-b border-gray-700">
                    <div class="flex items-center justify-between mb-3">
                        <div class="flex items-center gap-3">
                            <h1 class="text-xl font-bold">Telegram Archive</h1>
                            <!-- Stats Dropdown Button (hidden if SHOW_STATS=false) -->
                            <div class="relative" v-if="showStatsUI && statsData.stats_calculated_at">
                                <button @click="statsPopupOpen = !statsPopupOpen" 
                                    class="flex items-center gap-1.5 px-2 py-1 text-xs text-tg-muted hover:text-white hover:bg-gray-700/50 rounded transition">
                                    <span>üìä</span>
                                    <span>Stats</span>
                                    <svg :class="{'rotate-180': statsPopupOpen}" class="w-3 h-3 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                    </svg>
                                </button>
                                <!-- Stats Popup + Click-outside overlay -->
                                <div v-if="statsPopupOpen" @click="statsPopupOpen = false" class="fixed inset-0 z-40"></div>
                                <div v-if="statsPopupOpen" 
                                    class="absolute left-0 top-full mt-1 z-50 bg-gray-800 border border-gray-600 rounded-lg shadow-xl p-4 min-w-[220px]">
                                    <div class="text-xs text-tg-muted space-y-2">
                                        <div class="font-semibold text-white mb-3 pb-2 border-b border-gray-700">Backup Statistics</div>
                                        <div class="flex justify-between"><span>üí¨ Chats:</span><span class="text-white">{{ formatNumber(statsData.chats) }}</span></div>
                                        <div class="flex justify-between"><span>üì¨ Messages:</span><span class="text-white">{{ formatNumber(statsData.messages) }}</span></div>
                                        <div class="flex justify-between"><span>üñºÔ∏è Media files:</span><span class="text-white">{{ formatNumber(statsData.media_files) }}</span></div>
                                        <div class="flex justify-between"><span>üíæ Storage:</span><span class="text-white">{{ formatSize(statsData.total_size_mb) }}</span></div>
                                        <div class="pt-2 mt-2 border-t border-gray-700 text-[10px] opacity-70">
                                            {{ formatStatsTime(statsData.stats_calculated_at) }}
                                        </div>
                                        <!-- Footer -->
                                        <div class="pt-3 mt-3 border-t border-gray-700 text-center">
                                            <div class="text-[10px] opacity-70">
                                                Made with ‚ù§Ô∏è by <a href="https://geiser.cloud" target="_blank" class="text-blue-400 hover:text-blue-300">Sergio Fern√°ndez</a>
                                            </div>
                                            <a href="https://github.com/sponsors/GeiserX" target="_blank" 
                                                class="inline-flex items-center gap-1 mt-1.5 px-2 py-0.5 text-[9px] bg-pink-600/20 hover:bg-pink-600/30 text-pink-300 rounded transition">
                                                <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 16 16">
                                                    <path fill-rule="evenodd" d="M4.25 2.5c-1.336 0-2.75 1.164-2.75 3 0 2.15 1.58 4.144 3.365 5.682A20.565 20.565 0 008 13.393a20.561 20.561 0 003.135-2.211C12.92 9.644 14.5 7.65 14.5 5.5c0-1.836-1.414-3-2.75-3-1.373 0-2.609.986-3.029 2.456a.75.75 0 01-1.442 0C6.859 3.486 5.623 2.5 4.25 2.5zM8 14.25l-.345.666-.002-.001-.006-.003-.018-.01a7.643 7.643 0 01-.31-.17 22.075 22.075 0 01-3.434-2.414C2.045 10.731 0 8.35 0 5.5 0 2.836 2.086 1 4.25 1 5.797 1 7.153 1.802 8 3.02 8.847 1.802 10.203 1 11.75 1 13.914 1 16 2.836 16 5.5c0 2.85-2.045 5.231-3.885 6.818a22.08 22.08 0 01-3.744 2.584l-.018.01-.006.003h-.002L8 14.25zm0 0l.345.666a.752.752 0 01-.69 0L8 14.25z"></path>
                                                </svg>
                                                Sponsor
                                            </a>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <!-- Small loading indicator for stats/WS initialization -->
                        <div v-if="loadingStats" class="flex items-center gap-1.5 text-xs text-tg-muted">
                            <svg class="w-3.5 h-3.5 animate-spin" fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            <span>Syncing...</span>
                        </div>
                    </div>
                    
                    <div class="relative mb-3">
                        <input v-model="searchQuery" @input="onSearchInput" type="text" placeholder="Search all chats..."
                            class="w-full bg-gray-900 text-white rounded-lg pl-10 pr-4 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <svg class="w-5 h-5 text-gray-400 absolute left-3 top-2.5" fill="none" stroke="currentColor"
                            viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                        </svg>
                    </div>
                    <!-- Last Backup Time / Real-time Status -->
                    <div class="text-xs text-tg-muted">
                        <div class="flex items-center gap-1.5">
                            <template v-if="listenerActive">
                                <!-- Real-time mode indicator -->
                                <span class="relative flex h-2 w-2">
                                    <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
                                    <span class="relative inline-flex rounded-full h-2 w-2 bg-green-500"></span>
                                </span>
                                <span class="text-green-400">Real-time sync</span>
                                <span class="text-gray-500">‚Ä¢</span>
                                <span>Last backup: {{ formatLastBackupTime(lastBackupTime, viewerTimezone, lastBackupTimeSource) }}</span>
                            </template>
                            <template v-else>
                                <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                </svg>
                                <span>Last backup: {{ formatLastBackupTime(lastBackupTime, viewerTimezone, lastBackupTimeSource) }}</span>
                            </template>
                        </div>
                    </div>
                </div>

                <!-- Database Busy Error Banner -->
                <div v-if="chatsError" class="px-3 py-2 bg-amber-900/80 border-b border-amber-700">
                    <div class="flex items-center gap-2 text-amber-200 text-sm">
                        <svg class="w-5 h-5 shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                        </svg>
                        <span>{{ chatsError }}</span>
                        <button @click="loadChats()" class="ml-auto text-amber-300 hover:text-white text-xs underline">
                            Retry
                        </button>
                    </div>
                </div>

                <!-- Notification Permission Banner (shows when permission is 'default' AND notifications are enabled) -->
                <div v-if="(notificationsEnabled || pushEnabled) && notificationsSupported && notificationPermission === 'default'" 
                    class="px-3 py-2 bg-blue-900/80 border-b border-blue-700">
                    <div class="flex items-center gap-2 text-blue-200 text-sm">
                        <svg class="w-5 h-5 shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"></path>
                        </svg>
                        <span>Enable notifications for new messages</span>
                        <button @click="requestNotificationPermission()" 
                            class="ml-auto px-2 py-1 bg-blue-600 hover:bg-blue-500 text-white text-xs rounded transition">
                            Enable
                        </button>
                    </div>
                </div>
                
                <!-- Notifications Blocked Banner (shows when permission is 'denied' and user had subscribed) -->
                <div v-if="pushEnabled && notificationsSupported && notificationPermission === 'denied' && pushSubscribed" 
                    class="px-3 py-2 bg-amber-900/80 border-b border-amber-700">
                    <div class="flex items-center gap-2 text-amber-200 text-sm">
                        <svg class="w-5 h-5 shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M18.364 18.364A9 9 0 005.636 5.636m12.728 12.728A9 9 0 015.636 5.636m12.728 12.728L5.636 5.636"></path>
                        </svg>
                        <span>Notifications blocked by browser. Enable in browser settings to receive alerts.</span>
                        <button @click="unsubscribeFromPush()" 
                            class="ml-auto px-2 py-1 bg-amber-700 hover:bg-amber-600 text-white text-xs rounded transition">
                            Unsubscribe
                        </button>
                    </div>
                </div>

                <!-- Chat List -->
                <div class="flex-1 overflow-y-auto">
                    <!-- Loading spinner while chats are loading -->
                    <div v-if="loadingChats" class="flex flex-col items-center justify-center py-12 text-tg-muted">
                        <svg class="w-8 h-8 animate-spin mb-3" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        <span class="text-sm">Loading chats...</span>
                    </div>
                    <!-- Empty state -->
                    <div v-else-if="filteredChats.length === 0 && !chatsError" class="flex flex-col items-center justify-center py-12 text-tg-muted">
                        <svg class="w-12 h-12 mb-3 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                                d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path>
                        </svg>
                        <span class="text-sm">{{ searchQuery ? 'No chats found' : 'No chats yet' }}</span>
                    </div>
                    <div v-for="chat in filteredChats" :key="chat.id" @click="selectChat(chat)"
                        class="p-3 cursor-pointer hover:bg-tg-hover transition-colors flex items-center gap-3"
                        :class="{'bg-tg-active': selectedChat?.id === chat.id}">
                        <!-- Avatar -->
                        <div
                            class="w-12 h-12 rounded-full bg-gradient-to-br from-blue-500 to-purple-600 flex items-center justify-center text-lg font-bold text-white shrink-0 overflow-hidden relative">
                            <img v-if="chat.avatar_url" :src="chat.avatar_url" class="w-full h-full object-cover"
                                @error="chat.avatar_url = null" :alt="getChatName(chat)">
                            <template v-else-if="isDeletedChat(chat)">
                                <!-- Deleted account icon -->
                                <svg class="w-7 h-7 opacity-80" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M12 14c2.21 0 4-1.343 4-3s-1.79-3-4-3-4 1.343-4 3 1.79 3 4 3z" />
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M5 21a7 7 0 0114 0" />
                                </svg>
                            </template>
                            <template v-else>
                                {{ getInitials(chat) }}
                            </template>
                        </div>

                        <div class="flex-1 min-w-0">
                            <div class="flex justify-between items-baseline">
                                <h3 class="font-semibold truncate text-white">
                                    {{ getChatName(chat) }}
                                </h3>
                                <span class="text-xs text-tg-muted">{{ formatDate(chat.last_message_date) }}</span>
                            </div>
                            <p class="text-sm text-tg-muted truncate">
                                {{ chat.type }}
                                <span v-if="chat.type !== 'private' && chat.participants_count">
                                    ‚Ä¢ {{ chat.participants_count }} participants
                                </span>
                                <span class="text-tg-muted/70 text-xs font-mono ml-1">
                                    ‚Ä¢ ID: {{ chat.id }}
                                </span>
                            </p>
                        </div>
                    </div>
                    
                    <!-- Infinite Scroll Sentinel (loads more when visible) -->
                    <div v-if="hasMoreChats && !searchQuery" ref="infiniteScrollSentinel" class="p-3 flex justify-center">
                        <div v-if="loadingMoreChats" class="flex items-center gap-2 text-tg-muted text-sm">
                            <svg class="w-4 h-4 animate-spin" fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            <span>Loading more...</span>
                        </div>
                        <div v-else class="text-xs text-tg-muted opacity-50">
                            {{ chatTotal - chats.length }} more chats
                        </div>
                    </div>
                    
                    <!-- Search results info -->
                    <div v-if="searchQuery && !loadingChats" class="p-3 text-center text-xs text-tg-muted border-t border-gray-700/50">
                        <span v-if="searchResults.length > 0">Found {{ searchResults.length }} chats matching "{{ searchQuery }}"</span>
                        <span v-else>No chats found</span>
                    </div>
                </div>
            </div>

            <!-- Main Chat Area - full width on mobile -->
            <div class="flex-1 flex flex-col bg-tg-bg relative"
                :class="{'hidden md:flex': !selectedChat, 'flex': selectedChat}">
                <div v-if="!selectedChat" class="flex-1 flex items-center justify-center text-tg-muted flex-col">
                    <div class="bg-tg-sidebar p-6 rounded-full mb-4">
                        <svg class="w-12 h-12" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z">
                            </path>
                        </svg>
                    </div>
                    <p>Select a chat to view history</p>
                </div>

                <template v-else>
                    <!-- Chat Header -->
                    <div
                        class="p-4 bg-tg-sidebar border-b border-gray-700 flex items-center justify-between shadow-md z-10">
                        <div class="flex items-center gap-4">
                            <!-- Back Button (mobile only) -->
                            <button @click="selectedChat = null"
                                class="md:hidden p-2 -ml-2 text-gray-400 hover:text-white">
                                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M15 19l-7-7 7-7"></path>
                                </svg>
                            </button>
                            <div
                                class="w-10 h-10 rounded-full bg-gradient-to-br from-blue-500 to-purple-600 flex items-center justify-center font-bold text-white overflow-hidden relative">
                                <img v-if="selectedChat?.avatar_url" :src="selectedChat.avatar_url"
                                    class="w-full h-full object-cover" @error="selectedChat.avatar_url = null"
                                    :alt="getChatName(selectedChat)">
                                <template v-else-if="isDeletedChat(selectedChat)">
                                    <svg class="w-6 h-6 opacity-80" fill="none" stroke="currentColor"
                                        viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M12 14c2.21 0 4-1.343 4-3s-1.79-3-4-3-4 1.343-4 3 1.79 3 4 3z" />
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M5 21a7 7 0 0114 0" />
                                    </svg>
                                </template>
                                <template v-else>
                                    {{ getInitials(selectedChat) }}
                                </template>
                            </div>
                            <div>
                                <h2 class="font-bold text-lg">{{ getChatName(selectedChat) }}</h2>
                                <p class="text-xs text-tg-muted">{{ selectedChat.type }}</p>
                            </div>
                            <!-- Per-Chat Stats -->
                            <div v-if="chatStats" class="hidden sm:flex items-center gap-3 ml-4 px-3 py-1 bg-gray-800/50 rounded-lg text-xs text-tg-muted">
                                <span title="Messages in this chat">üì¨ {{ formatNumber(chatStats.messages) }} msgs</span>
                                <span v-if="chatStats.media_files > 0" title="Media files">üñºÔ∏è {{ formatNumber(chatStats.media_files) }} media</span>
                                <span v-if="chatStats.total_size_mb > 0" title="Storage used">üíæ {{ formatSize(chatStats.total_size_mb) }}</span>
                            </div>
                            <!-- Loading indicator for chat stats -->
                            <div v-else-if="selectedChat && !chatStats" class="hidden sm:flex items-center ml-4 text-xs text-tg-muted opacity-50">
                                <svg class="w-3 h-3 animate-spin mr-1" fill="none" viewBox="0 0 24 24">
                                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                </svg>
                            </div>
                        </div>

                        <div class="flex items-center gap-2">
                            <!-- Search Bar -->
                            <div class="relative w-64">
                                <input v-model="messageSearchQuery" @input="searchMessages" type="text"
                                    placeholder="Search in chat..."
                                    class="w-full bg-gray-900 text-white rounded-lg pl-10 pr-4 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                                <svg class="w-4 h-4 text-gray-400 absolute left-3 top-2.5" fill="none"
                                    stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                                </svg>
                            </div>

                            <!-- Export Button -->
                            <button @click="exportChat"
                                class="p-2 text-gray-400 hover:text-white rounded-lg hover:bg-white/10 transition"
                                title="Export Chat to JSON">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                                </svg>
                            </button>
                        </div>
                    </div>

                    <!-- Messages -->
                    <div class="flex-1 relative overflow-hidden">
                    <div ref="messagesContainer" class="absolute inset-0 overflow-y-auto p-4 space-y-1" @scroll="handleScroll">
                        <div v-if="loading && messages.length === 0" class="text-center py-4 text-tg-muted">
                            Loading messages...
                        </div>

                        <template v-for="(msg, index) in sortedMessages" :key="msg.id">
                            <!-- Date Separator -->
                            <div v-if="showDateSeparator(index)" class="date-separator">
                                <span @click="openDatePicker(msg.date)">{{ formatDateFull(msg.date) }}</span>
                            </div>

                            <!-- Message -->
                            <div class="flex" :class="isOwnMessage(msg) ? 'justify-end' : 'justify-start'">
                                <div class="message-bubble p-3 text-sm shadow-sm text-gray-100"
                                    :style="getSenderStyle(msg)">
                                    <!-- Sender Name (if group and first in sequence) -->
                                    <div v-if="!isOwnMessage(msg) && isGroup && showSenderName(index)"
                                        class="text-xs font-bold mb-1" :style="{ color: getSenderNameColor(msg) }">
                                        {{ getSenderName(msg) }}
                                    </div>

                                    <!-- Reply Context -->
                                    <div v-if="msg.reply_to_msg_id" @click="scrollToMessage(msg.reply_to_msg_id)"
                                        class="border-l-2 border-blue-400/50 pl-2 mb-2 text-xs bg-black/20 rounded p-2 cursor-pointer hover:bg-black/30 transition">
                                        <div class="font-semibold text-blue-400 mb-0.5">Reply to</div>
                                        <div class="truncate opacity-70">{{ msg.reply_to_text || 'Message' }}</div>
                                    </div>

                                    <!-- Polls -->
                                    <div v-if="msg.media_type === 'poll' && msg.raw_data && msg.raw_data.poll"
                                        class="mb-2 w-full max-w-sm bg-black/20 rounded-lg p-3">
                                        <div class="font-bold text-sm mb-3">{{ msg.raw_data.poll.question }}</div>

                                        <div class="space-y-2">
                                            <div v-for="answer in msg.raw_data.poll.answers" :key="answer.option"
                                                class="relative group">
                                                <!-- Use a wrapper for the bar to show visual progress behind text -->
                                                <div
                                                    class="relative w-full border border-white/10 rounded-md overflow-hidden bg-white/5">
                                                    <!-- Progress Bar -->
                                                    <div v-if="getPollPercentage(msg, answer) > 0"
                                                        class="absolute left-0 top-0 bottom-0 bg-blue-500/30 transition-all duration-500"
                                                        :style="{ width: getPollPercentage(msg, answer) + '%' }">
                                                    </div>

                                                    <!-- Text and Percentage -->
                                                    <div
                                                        class="relative z-10 flex justify-between items-center px-3 py-2">
                                                        <span class="text-sm truncate mr-2">{{ answer.text }}</span>
                                                        <span v-if="msg.raw_data.poll.results"
                                                            class="text-xs font-bold shrink-0">
                                                            {{ getPollPercentage(msg, answer) }}%
                                                        </span>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>

                                        <div
                                            class="mt-3 flex justify-between items-center text-[10px] opacity-60 uppercase tracking-wider font-semibold">
                                            <span>{{ msg.raw_data.poll.quiz ? 'Quiz' : 'Poll' }}</span>
                                            <span v-if="msg.raw_data.poll.results">
                                                {{ msg.raw_data.poll.results.total_voters }} votes
                                            </span>
                                        </div>
                                    </div>

                                    <!-- Media (show if media exists, even if not yet downloaded) -->
                                    <div v-if="msg.media_path || msg.media_type" class="mb-2 space-y-1">
                                        <!-- Placeholder for media not yet downloaded -->
                                        <div v-if="!msg.media_path && msg.media_type" 
                                            class="bg-gray-700/50 rounded-lg p-4 flex items-center gap-3 max-w-md">
                                            <svg class="w-8 h-8 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                                                    d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                                            </svg>
                                            <div>
                                                <div class="text-sm text-gray-300">{{ msg.media_type }}</div>
                                                <div class="text-xs text-gray-500">Will download on next backup</div>
                                            </div>
                                        </div>
                                    </div>
                                    <div v-if="msg.media_path" class="mb-2 space-y-1">
                                        <!-- Album Grid (multiple photos/videos grouped together) -->
                                        <div v-if="isFirstInAlbum(msg, index)" class="album-grid">
                                            <div class="grid gap-1" :class="getAlbumGridClass(getAlbumForMessage(msg))">
                                                <template v-for="albumMsg in getAlbumForMessage(msg)" :key="albumMsg.id">
                                                    <div class="album-item relative overflow-hidden rounded-lg cursor-pointer hover:opacity-90 transition"
                                                        @click="openMedia(albumMsg)">
                                                        <img v-if="albumMsg.media_type === 'photo'" 
                                                            :src="getMediaUrl(albumMsg)"
                                                            loading="lazy"
                                                            class="w-full h-full object-cover"
                                                            @error="handleImageError($event, albumMsg)">
                                                        <video v-else-if="albumMsg.media_type === 'video'" 
                                                            class="w-full h-full object-cover"
                                                            preload="metadata">
                                                            <source :src="getMediaUrl(albumMsg)" type="video/mp4">
                                                        </video>
                                                        <!-- Video indicator overlay -->
                                                        <div v-if="albumMsg.media_type === 'video'" 
                                                            class="absolute inset-0 flex items-center justify-center bg-black/20">
                                                            <svg class="w-10 h-10 text-white/90" fill="currentColor" viewBox="0 0 24 24">
                                                                <path d="M8 5v14l11-7z"/>
                                                            </svg>
                                                        </div>
                                                    </div>
                                                </template>
                                            </div>
                                        </div>
                                        
                                        <!-- Regular photo (not part of album) -->
                                        <img v-else-if="msg.media_type === 'photo' && !msg.raw_data?.grouped_id" :src="getMediaUrl(msg)"
                                            loading="lazy"
                                            class="rounded-lg max-h-64 max-w-full object-cover cursor-pointer hover:opacity-90 transition"
                                            @click="openMedia(msg)" @error="handleImageError($event, msg)">

                                        <!-- Audio / Voice Notes -->
                                        <div v-else-if="isAudioFile(msg)"
                                            class="w-full min-w-[250px] max-w-md bg-gradient-to-r from-gray-800 to-gray-700 p-3 rounded-xl shadow-lg">
                                            <audio 
                                                controls 
                                                preload="metadata" 
                                                class="w-full" 
                                                style="height: 40px; min-height: 40px;"
                                                :src="getMediaUrl(msg)"
                                                @error="console.error('Audio load error:', getMediaUrl(msg))">
                                                Your browser does not support audio playback.
                                            </audio>
                                            <div class="flex items-center gap-2 mt-2 text-xs text-gray-400">
                                                <span>üéµ</span>
                                                <span class="truncate">{{ getDocumentDisplayName(msg) }}</span>
                                            </div>
                                        </div>

                                        <!-- GIFs / Animations - autoplay when visible -->
                                        <video v-else-if="msg.media_type === 'animation'" :data-src="getMediaUrl(msg)"
                                            class="rounded-lg max-h-64 w-auto max-w-full gif-video" loop muted
                                            playsinline @click="openMedia(msg)">
                                        </video>

                                        <!-- Videos -->
                                        <video v-else-if="msg.media_type === 'video'" controls preload="none"
                                            class="rounded-lg max-h-64 w-full"
                                            @error="handleMediaError($event, msg)">
                                            <source :src="getMediaUrl(msg)" type="video/mp4">
                                        </video>

                                        <!-- Stickers (static/animated) -->
                                        <div v-else-if="msg.media_type === 'sticker'" class="max-w-[200px]">
                                            <img v-if="getDocumentDisplayName(msg).endsWith('.webp')"
                                                :src="getMediaUrl(msg)" loading="lazy" 
                                                class="max-h-48 max-w-full object-contain"
                                                @error="handleImageError($event, msg)">
                                            <div v-else class="text-xs text-tg-muted p-2 bg-black/20 rounded">
                                                üé≠ Animated Sticker
                                            </div>
                                        </div>

                                        <!-- Documents that are actually images: show inline preview + filename -->
                                        <div v-else-if="msg.media_type === 'document' && isImageDocument(msg)"
                                            class="space-y-1">
                                            <img :src="getMediaUrl(msg)"
                                                loading="lazy"
                                                class="rounded-lg max-h-48 max-w-full object-cover cursor-pointer hover:opacity-90 transition"
                                                @click="openMedia(msg)" @error="handleImageError($event, msg)">
                                            <div class="flex items-center justify-between text-[11px] opacity-80">
                                                <span class="truncate mr-2">{{ getDocumentDisplayName(msg) }}</span>
                                                <a :href="getMediaUrl(msg)" download
                                                    class="text-blue-400 hover:text-blue-300 whitespace-nowrap">
                                                    Download
                                                </a>
                                            </div>
                                        </div>

                                        <!-- Other documents / files -->
                                        <a v-else :href="getMediaUrl(msg)" download
                                            class="flex items-center gap-2 bg-black/20 p-2 rounded hover:bg-black/30 transition">
                                            <svg class="w-6 h-6 shrink-0" fill="none" stroke="currentColor"
                                                viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                    d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z">
                                                </path>
                                            </svg>
                                            <div class="flex flex-col text-xs">
                                                <span class="font-medium truncate">
                                                    {{ getDocumentDisplayName(msg) }}
                                                </span>
                                                <span class="text-[10px] text-tg-muted" v-if="msg.media_type">
                                                    {{ msg.media_type }} file
                                                </span>
                                            </div>
                                        </a>
                                    </div>

                                    <!-- Text with clickable links -->
                                    <div class="whitespace-pre-wrap break-words message-text"
                                        v-html="linkifyText(msg.text)"></div>

                                    <!-- Reactions -->
                                    <div v-if="msg.reactions && msg.reactions.length > 0" class="mt-2 flex flex-wrap gap-1.5">
                                        <div v-for="reaction in msg.reactions" :key="reaction.emoji"
                                            class="inline-flex items-center gap-1 px-2 py-1 rounded-full transition"
                                            :class="isOwnMessage(msg) ? 'bg-blue-500/20 hover:bg-blue-500/30' : 'bg-black/20 hover:bg-black/30'"
                                            :title="reaction.count > 1 ? `${reaction.count} reactions` : '1 reaction'">
                                            <span class="text-sm">{{ formatReactionEmoji(reaction.emoji) }}</span>
                                            <span v-if="reaction.count > 1" class="text-[11px] font-medium opacity-80">{{ reaction.count }}</span>
                                        </div>
                                    </div>

                                    <!-- Metadata -->
                                    <div
                                        class="text-[10px] opacity-60 text-right mt-1 flex justify-end items-center gap-1">
                                        <span v-if="msg.edit_date">edited</span>
                                        {{ formatTime(msg.date) }}
                                    </div>
                                </div>
                            </div>
                        </template>

                        <div v-if="loading && messages.length > 0" class="text-center py-2 text-tg-muted text-sm">
                            Loading more...
                        </div>

                        <div ref="scrollAnchor"></div>
                    </div>

                    <!-- Scroll to Bottom Button -->
                    <button v-if="showScrollToBottom" 
                        @click="scrollToLatest"
                        class="scroll-to-bottom-btn"
                        title="Scroll to latest messages">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 14l-7 7m0 0l-7-7m7 7V3"></path>
                        </svg>
                    </button>
                    </div>
                </template>
            </div>
        </div>

        <!-- Date Picker Modal -->
        <div v-if="showDatePickerModal" 
            class="fixed inset-0 bg-black/70 backdrop-blur-sm z-50 flex items-center justify-center p-4"
            @click.self="closeDatePicker">
            <div class="bg-tg-sidebar rounded-2xl shadow-2xl p-6 w-full max-w-md border border-gray-700">
                <div class="flex items-center justify-between mb-4">
                    <h3 class="text-xl font-bold text-white">Jump to Date</h3>
                    <button @click="closeDatePicker" 
                        class="text-gray-400 hover:text-white transition p-1">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                <div class="mb-4">
                    <input ref="datePickerInput" type="text" 
                        class="w-full bg-gray-900 text-white rounded-lg px-4 py-3 focus:outline-none focus:ring-2 focus:ring-blue-500"
                        placeholder="Select a date">
                </div>
                <div class="flex gap-2 justify-end">
                    <button @click="closeDatePicker"
                        class="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded-lg transition">
                        Cancel
                    </button>
                    <button @click="jumpToDate"
                        class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition">
                        Jump
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, computed, onMounted, watch, nextTick } = Vue

        createApp({
            setup() {
                const chats = ref([])
                const messages = ref([])
                const selectedChat = ref(null)
                const searchQuery = ref('')
                const messageSearchQuery = ref('')
                const loading = ref(false)
                const loadingChats = ref(true)  // Start as true, loading on init
                const loadingStats = ref(true)  // Start as true, loading on init
                const page = ref(0)
                const hasMore = ref(true)
                const messagesContainer = ref(null)
                const scrollAnchor = ref(null)
                const isAuthenticated = ref(false)
                const authRequired = ref(false)
                const authCheckFailed = ref(false)
                const loadingAuth = ref(true)
                const loginForm = ref({ username: '', password: '' })
                const loginError = ref('')
                const chatsError = ref('')  // Error message when database is busy
                const lastBackupTime = ref(null)  // Last backup time from stats
                const lastBackupTimeSource = ref('metadata')  // Source of last backup time: 'metadata' (UTC) or 'sync_status' (server local)
                const listenerActive = ref(false)  // Whether real-time listener is active
                const viewerTimezone = ref('Europe/Madrid')  // Default timezone, will be updated from config
                const showDatePickerModal = ref(false)
                const datePickerInput = ref(null)
                const selectedDate = ref(null)
                let flatpickrInstance = null
                const showScrollToBottom = ref(false)

                // WebSocket and Notifications (v5.0)
                const notificationsEnabled = ref(false)
                const notificationsSupported = ref('Notification' in window)
                const notificationPermission = ref(Notification?.permission || 'denied')
                const pushEnabled = ref(false)  // Web Push (works when tab closed)
                const pushSubscribed = ref(false)  // Currently subscribed to push
                const pushVapidKey = ref(null)  // VAPID public key for push subscription
                let ws = null
                let wsReconnectTimer = null
                let messageRefreshTimer = null  // Timer for auto-refreshing messages
                let pushSubscription = null  // Current push subscription object

                // Intersection Observer for GIF autoplay
                let gifObserver = null

                // Chat pagination state
                const chatOffset = ref(0)
                const chatTotal = ref(0)
                const hasMoreChats = ref(true)
                const loadingMoreChats = ref(false)
                const infiniteScrollSentinel = ref(null)
                let infiniteScrollObserver = null
                
                // Server-side search
                const searchResults = ref([])
                const searchLoading = ref(false)
                let searchDebounceTimer = null
                
                const loadChats = async (append = false) => {
                    if (!append) {
                        loadingChats.value = true
                        chatOffset.value = 0
                    } else {
                        loadingMoreChats.value = true
                    }
                    
                    try {
                        const limit = 50
                        const offset = append ? chatOffset.value : 0
                        const res = await fetch(`/api/chats?limit=${limit}&offset=${offset}`, {
                            credentials: 'include'
                        })
                        if (!res.ok) {
                            if (res.status === 401) {
                                isAuthenticated.value = false
                                return
                            }
                            if (res.status === 503) {
                                const data = await res.json().catch(() => ({}))
                                chatsError.value = data.detail || 'Database is busy. Please wait and refresh.'
                                return
                            }
                            throw new Error('Failed to fetch chats')
                        }
                        chatsError.value = ''
                        const data = await res.json()
                        
                        if (append) {
                            chats.value.push(...data.chats)
                        } else {
                            chats.value = data.chats
                        }
                        
                        chatTotal.value = data.total
                        hasMoreChats.value = data.has_more
                        chatOffset.value = offset + data.chats.length
                        
                    } catch (e) {
                        console.error("Failed to fetch chats", e)
                        if (e.message.includes('401') || e.message.includes('Unauthorized')) {
                            isAuthenticated.value = false
                        } else {
                            chatsError.value = 'Failed to load chats. Please try again.'
                        }
                    } finally {
                        loadingChats.value = false
                        loadingMoreChats.value = false
                    }
                }
                
                const loadMoreChats = () => {
                    if (!loadingMoreChats.value && hasMoreChats.value && !searchQuery.value) {
                        loadChats(true)
                    }
                }
                
                // Server-side search with debounce
                const onSearchInput = () => {
                    if (searchDebounceTimer) {
                        clearTimeout(searchDebounceTimer)
                    }
                    
                    const query = searchQuery.value.trim()
                    
                    if (!query) {
                        searchResults.value = []
                        searchLoading.value = false
                        return
                    }
                    
                    searchLoading.value = true
                    searchDebounceTimer = setTimeout(async () => {
                        try {
                            // Search ALL chats server-side (no pagination limit)
                            const res = await fetch(`/api/chats?search=${encodeURIComponent(query)}&limit=1000`, {
                                credentials: 'include'
                            })
                            if (res.ok) {
                                const data = await res.json()
                                searchResults.value = data.chats
                            }
                        } catch (e) {
                            console.error('Search failed:', e)
                        } finally {
                            searchLoading.value = false
                        }
                    }, 300) // 300ms debounce
                }
                
                // Setup infinite scroll observer
                const setupInfiniteScroll = () => {
                    if (infiniteScrollObserver) {
                        infiniteScrollObserver.disconnect()
                    }
                    
                    infiniteScrollObserver = new IntersectionObserver(
                        (entries) => {
                            if (entries[0].isIntersecting && hasMoreChats.value && !loadingMoreChats.value && !searchQuery.value) {
                                loadMoreChats()
                            }
                        },
                        { rootMargin: '100px' }
                    )
                    
                    // Watch for sentinel to be added to DOM
                    nextTick(() => {
                        if (infiniteScrollSentinel.value) {
                            infiniteScrollObserver.observe(infiniteScrollSentinel.value)
                        }
                    })
                }

                // Stats data
                const statsData = ref({
                    chats: 0,
                    messages: 0,
                    media_files: 0,
                    total_size_mb: 0,
                    stats_calculated_at: null
                })
                const statsPopupOpen = ref(false)
                const showStatsUI = ref(true)  // Can be disabled via SHOW_STATS=false
                
                const loadStats = async () => {
                    try {
                        const res = await fetch('/api/stats', {
                            credentials: 'include'
                        })
                        if (res.ok) {
                            const stats = await res.json()
                            console.log('Stats loaded:', stats)
                            
                            // Store stats data
                            statsData.value = {
                                chats: stats.chats || 0,
                                messages: stats.messages || 0,
                                media_files: stats.media_files || 0,
                                total_size_mb: stats.total_size_mb || 0,
                                stats_calculated_at: stats.stats_calculated_at
                            }
                            
                            // Show/hide stats UI based on config
                            showStatsUI.value = stats.show_stats !== false
                            
                            // Update timezone from config
                            if (stats.timezone) {
                                viewerTimezone.value = stats.timezone
                                if (moment && moment.tz) {
                                    moment.tz.setDefault(viewerTimezone.value)
                                }
                            }
                            
                            // Last backup time
                            if (stats.last_backup_time) {
                                lastBackupTime.value = stats.last_backup_time
                                lastBackupTimeSource.value = stats.last_backup_time_source || 'metadata'
                            } else {
                                lastBackupTime.value = null
                                lastBackupTimeSource.value = 'metadata'
                            }
                            
                            // Real-time listener status
                            listenerActive.value = !!stats.listener_active
                        } else {
                            console.error('Failed to fetch stats, status:', res.status)
                        }
                    } catch (e) {
                        console.error("Failed to fetch stats", e)
                    }
                }
                
                const formatStatsTime = (isoString) => {
                    if (!isoString) return 'Never calculated'
                    const date = moment(isoString)
                    const now = moment()
                    const diffHours = now.diff(date, 'hours')
                    if (diffHours < 1) {
                        return 'Updated ' + date.fromNow()
                    }
                    if (diffHours < 24) {
                        return 'Updated ' + diffHours + 'h ago'
                    }
                    return 'Updated ' + date.format('MMM D')
                }
                
                // Format large numbers with K/M suffix
                const formatNumber = (num) => {
                    if (num >= 1000000) {
                        return (num / 1000000).toFixed(1).replace(/\.0$/, '') + 'M'
                    }
                    if (num >= 1000) {
                        return (num / 1000).toFixed(1).replace(/\.0$/, '') + 'K'
                    }
                    return num.toLocaleString()
                }
                
                // Format size in MB to appropriate unit (MB, GB, TB)
                const formatSize = (sizeMB) => {
                    if (!sizeMB || sizeMB === 0) return '0 MB'
                    if (sizeMB >= 1024 * 1024) {
                        return (sizeMB / (1024 * 1024)).toFixed(2) + ' TB'
                    }
                    if (sizeMB >= 1024) {
                        return (sizeMB / 1024).toFixed(1) + ' GB'
                    }
                    return sizeMB.toFixed(0) + ' MB'
                }
                
                // Mark initialization complete (called after WS connects and notifications init)
                const finishInitialization = () => {
                    loadingStats.value = false
                }

                // Auth check on mount
                onMounted(async () => {
                    try {
                        const res = await fetch('/api/auth/check', {
                            credentials: 'include'
                        })
                        if (res.ok) {
                            const data = await res.json()
                            authRequired.value = !!data.auth_required
                            isAuthenticated.value = !!data.authenticated

                            if (isAuthenticated.value) {
                                await loadChats()
                                await loadStats()
                                setupInfiniteScroll()
                            }
                        } else {
                            // If status endpoint fails, show login form with warning
                            console.warn('Failed to get auth status, showing login form')
                            authCheckFailed.value = true
                            authRequired.value = true  // Show login form
                            isAuthenticated.value = false
                        }
                    } catch (e) {
                        // On network error, show login form with warning  
                        console.error('Auth status error', e)
                        authCheckFailed.value = true
                        authRequired.value = true  // Show login form
                        isAuthenticated.value = false
                    } finally {
                        loadingAuth.value = false
                    }
                    
                    // Initialize WebSocket and notifications (v5.0)
                    await initNotifications()
                    initWebSocket()
                    
                    // Mark secondary initialization complete
                    finishInitialization()
                })

                // WebSocket initialization for real-time updates
                const initWebSocket = () => {
                    if (ws) {
                        ws.close()
                    }
                    
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:'
                    const wsUrl = `${protocol}//${window.location.host}/ws/updates`
                    
                    try {
                        ws = new WebSocket(wsUrl)
                        
                        ws.onopen = () => {
                            console.log('[WS] Connected to real-time updates')
                            // Subscribe to current chat if selected
                            if (selectedChat.value) {
                                ws.send(JSON.stringify({
                                    action: 'subscribe',
                                    chat_id: selectedChat.value.id
                                }))
                            }
                        }
                        
                        ws.onmessage = (event) => {
                            try {
                                const data = JSON.parse(event.data)
                                handleWebSocketMessage(data)
                            } catch (e) {
                                console.error('[WS] Parse error:', e)
                            }
                        }
                        
                        ws.onclose = () => {
                            console.log('[WS] Connection closed, reconnecting in 5s...')
                            wsReconnectTimer = setTimeout(initWebSocket, 5000)
                        }
                        
                        ws.onerror = (e) => {
                            console.warn('[WS] Error:', e)
                        }
                    } catch (e) {
                        console.warn('[WS] Failed to connect:', e)
                    }
                }
                
                const handleWebSocketMessage = (data) => {
                    switch (data.type) {
                        case 'new_message':
                            // Add to messages if we're viewing that chat
                            if (selectedChat.value?.id === data.chat_id) {
                                messages.value.push(data.message)
                            }
                            // Show notification
                            if (notificationPermission.value === 'granted' && document.hidden) {
                                showNotification(data)
                            }
                            break
                        
                        case 'edit':
                            // Update message text in current view
                            const editMsg = messages.value.find(m => m.id === data.message_id)
                            if (editMsg) {
                                editMsg.text = data.new_text
                                editMsg.edit_date = data.edit_date
                            }
                            break
                        
                        case 'delete':
                            // Remove from current view
                            const deleteIdx = messages.value.findIndex(m => m.id === data.message_id)
                            if (deleteIdx !== -1) {
                                messages.value.splice(deleteIdx, 1)
                            }
                            break
                        
                        case 'subscribed':
                            console.log('[WS] Subscribed to chat:', data.chat_id)
                            break
                    }
                }
                
                // Notification functions
                const initNotifications = async () => {
                    // Check push notification config from server
                    try {
                        const pushRes = await fetch('/api/push/config', { credentials: 'include' })
                        if (pushRes.ok) {
                            const pushConfig = await pushRes.json()
                            pushEnabled.value = pushConfig.enabled
                            pushVapidKey.value = pushConfig.vapid_public_key
                            console.log('[Push] Config:', pushConfig)
                        }
                    } catch (e) {
                        console.warn('[Push] Could not fetch config:', e)
                    }
                    
                    // Check basic notification settings
                    try {
                        const res = await fetch('/api/notifications/settings', { credentials: 'include' })
                        if (res.ok) {
                            const data = await res.json()
                            notificationsEnabled.value = data.enabled
                            if (data.enabled) {
                                console.log('[Notifications] ‚úÖ Enabled by server')
                            } else {
                                console.log('[Notifications] ‚ùå Disabled by server:', data.reason || 'unknown')
                            }
                        }
                    } catch (e) {
                        // Fallback: enable if push is enabled
                        if (pushEnabled.value) {
                            notificationsEnabled.value = true
                        }
                    }
                    
                    // Log notification state for debugging
                    console.log('[Notifications] State:', {
                        serverEnabled: notificationsEnabled.value,
                        browserSupported: notificationsSupported.value,
                        permission: notificationPermission.value,
                        pushEnabled: pushEnabled.value,
                        pushSubscribed: pushSubscribed.value
                    })
                    
                    // Register service worker (required for both basic and push notifications)
                    if ('serviceWorker' in navigator && (notificationsEnabled.value || pushEnabled.value)) {
                        try {
                            const registration = await navigator.serviceWorker.register('/static/sw.js')
                            console.log('[SW] Service worker registered')
                            
                            // Check for existing push subscription
                            if (pushEnabled.value && 'PushManager' in window) {
                                pushSubscription = await registration.pushManager.getSubscription()
                                if (pushSubscription) {
                                    pushSubscribed.value = true
                                    console.log('[Push] Already subscribed')
                                }
                            }
                        } catch (e) {
                            console.warn('[SW] Registration failed:', e)
                        }
                    }
                }
                
                const requestNotificationPermission = async () => {
                    if (!notificationsSupported.value) return
                    
                    try {
                        const permission = await Notification.requestPermission()
                        notificationPermission.value = permission
                        
                        // Auto-subscribe to push if permission granted and push is enabled
                        if (permission === 'granted' && pushEnabled.value && !pushSubscribed.value) {
                            await subscribeToPush()
                        }
                    } catch (e) {
                        console.error('Notification permission error:', e)
                    }
                }
                
                // Convert VAPID public key from base64 to Uint8Array
                const urlBase64ToUint8Array = (base64String) => {
                    const padding = '='.repeat((4 - base64String.length % 4) % 4)
                    const base64 = (base64String + padding)
                        .replace(/\-/g, '+')
                        .replace(/_/g, '/')
                    const rawData = window.atob(base64)
                    const outputArray = new Uint8Array(rawData.length)
                    for (let i = 0; i < rawData.length; ++i) {
                        outputArray[i] = rawData.charCodeAt(i)
                    }
                    return outputArray
                }
                
                const subscribeToPush = async () => {
                    if (!pushEnabled.value || !pushVapidKey.value) {
                        console.log('[Push] Not enabled or no VAPID key')
                        return false
                    }
                    
                    if (!('serviceWorker' in navigator) || !('PushManager' in window)) {
                        console.log('[Push] Not supported in this browser')
                        return false
                    }
                    
                    try {
                        const registration = await navigator.serviceWorker.ready
                        
                        // Subscribe to push
                        pushSubscription = await registration.pushManager.subscribe({
                            userVisibleOnly: true,
                            applicationServerKey: urlBase64ToUint8Array(pushVapidKey.value)
                        })
                        
                        // Send subscription to server
                        const response = await fetch('/api/push/subscribe', {
                            method: 'POST',
                            credentials: 'include',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(pushSubscription.toJSON())
                        })
                        
                        if (response.ok) {
                            pushSubscribed.value = true
                            console.log('[Push] ‚úÖ Subscribed successfully')
                            return true
                        } else {
                            console.error('[Push] Failed to store subscription:', await response.text())
                            return false
                        }
                    } catch (e) {
                        console.error('[Push] Subscription error:', e)
                        return false
                    }
                }
                
                const unsubscribeFromPush = async () => {
                    if (!pushSubscription) return
                    
                    try {
                        // Unsubscribe from push service
                        await pushSubscription.unsubscribe()
                        
                        // Remove from server
                        await fetch('/api/push/unsubscribe', {
                            method: 'POST',
                            credentials: 'include',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ endpoint: pushSubscription.endpoint })
                        })
                        
                        pushSubscription = null
                        pushSubscribed.value = false
                        console.log('[Push] Unsubscribed')
                    } catch (e) {
                        console.error('[Push] Unsubscribe error:', e)
                    }
                }
                
                const showNotification = (data) => {
                    if (notificationPermission.value !== 'granted') return
                    
                    // Skip if push is enabled (service worker handles it)
                    if (pushEnabled.value && pushSubscribed.value) return
                    
                    const chatName = chats.value.find(c => c.id === data.chat_id)?.title || 'New Message'
                    const body = data.message?.text?.substring(0, 100) || 'New message received'
                    
                    new Notification(chatName, {
                        body: body,
                        icon: '/static/favicon.ico',
                        tag: `chat-${data.chat_id}`,
                        data: { chat_id: data.chat_id }
                    })
                }

                // Setup Intersection Observer for GIF autoplay
                const setupGifObserver = () => {
                    if (gifObserver) {
                        gifObserver.disconnect()
                    }

                    gifObserver = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            const video = entry.target
                            if (entry.isIntersecting) {
                                // Load and play when visible
                                if (!video.src && video.dataset.src) {
                                    video.src = video.dataset.src
                                }
                                video.play().catch(() => { })
                            } else {
                                // Pause when not visible
                                video.pause()
                            }
                        })
                    }, { threshold: 0.1 })
                }

                // Watch for messages changes to observe new GIFs
                watch(messages, () => {
                    nextTick(() => {
                        if (!gifObserver) setupGifObserver()
                        document.querySelectorAll('.gif-video').forEach(video => {
                            gifObserver.observe(video)
                        })
                    })
                }, { deep: true })
                
                // Subscribe to WebSocket updates when chat changes
                watch(selectedChat, (newChat, oldChat) => {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        // Unsubscribe from old chat
                        if (oldChat) {
                            ws.send(JSON.stringify({
                                action: 'unsubscribe',
                                chat_id: oldChat.id
                            }))
                        }
                        // Subscribe to new chat
                        if (newChat) {
                            ws.send(JSON.stringify({
                                action: 'subscribe',
                                chat_id: newChat.id
                            }))
                        }
                    }
                })

                const performLogin = async () => {
                    loginError.value = ''
                    loadingAuth.value = true
                    try {
                        const res = await fetch('/api/login', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'include',
                            body: JSON.stringify(loginForm.value),
                        })

                        if (!res.ok) {
                            if (res.status === 401) {
                                loginError.value = 'Invalid username or password'
                                return
                            }
                            throw new Error('Login failed')
                        }

                        const data = await res.json()
                        if (data.success) {
                            isAuthenticated.value = true
                            await loadChats()
                            await loadStats()
                            // Re-initialize notifications after login (cookie now set)
                            await initNotifications()
                        } else {
                            loginError.value = 'Login failed'
                        }
                    } catch (e) {
                        console.error('Login error', e)
                        loginError.value = 'Unexpected error, please try again'
                    } finally {
                        loadingAuth.value = false
                    }
                }

                const filteredChats = computed(() => {
                    // If searching, use server-side search results
                    if (searchQuery.value.trim()) {
                        return searchResults.value
                    }
                    // Otherwise, show paginated chats
                    return chats.value
                })

                const sortedMessages = computed(() => {
                    // Sort messages by date (oldest first) for chronological display
                    // Note: Can't just reverse since jumpToDate may add messages out of order
                    return [...messages.value].sort((a, b) => 
                        new Date(a.date).getTime() - new Date(b.date).getTime()
                    )
                })
                
                // Group consecutive messages that belong to an album (same grouped_id)
                const getAlbumForMessage = (msg) => {
                    const groupedId = msg.raw_data?.grouped_id
                    if (!groupedId) return null
                    
                    // Find all messages in this album
                    return sortedMessages.value.filter(m => m.raw_data?.grouped_id === groupedId)
                }
                
                // Check if this message is the first in its album (render the album here)
                const isFirstInAlbum = (msg, index) => {
                    const groupedId = msg.raw_data?.grouped_id
                    if (!groupedId) return false
                    
                    // Check if previous message has same grouped_id
                    if (index > 0) {
                        const prevMsg = sortedMessages.value[index - 1]
                        if (prevMsg.raw_data?.grouped_id === groupedId) {
                            return false  // Not first, skip rendering here
                        }
                    }
                    return true  // First in album, render the album grid
                }
                
                // Check if this message should be hidden (it's part of album but not first)
                const isHiddenAlbumMessage = (msg, index) => {
                    const groupedId = msg.raw_data?.grouped_id
                    if (!groupedId) return false
                    return !isFirstInAlbum(msg, index)
                }
                
                // Get grid layout class based on album size (like Telegram)
                const getAlbumGridClass = (album) => {
                    if (!album) return 'grid-cols-1'
                    const count = album.length
                    switch (count) {
                        case 1: return 'grid-cols-1'
                        case 2: return 'grid-cols-2'
                        case 3: return 'grid-cols-2'  // 2+1 layout
                        case 4: return 'grid-cols-2'  // 2x2 grid
                        default: return 'grid-cols-3'  // 3+ items = 3 columns
                    }
                }

                const isGroup = computed(() => {
                    return selectedChat.value && (selectedChat.value.type === 'group' || selectedChat.value.type === 'channel')
                })

                // Per-chat statistics
                const chatStats = ref(null)
                
                const loadChatStats = async (chatId) => {
                    try {
                        const res = await fetch(`/api/chats/${chatId}/stats`, {
                            credentials: 'include'
                        })
                        if (res.ok) {
                            chatStats.value = await res.json()
                        }
                    } catch (e) {
                        console.error('Failed to load chat stats:', e)
                        chatStats.value = null
                    }
                }
                
                const selectChat = async (chat) => {
                    selectedChat.value = chat
                    messages.value = []
                    page.value = 0
                    hasMore.value = true
                    messageSearchQuery.value = ''
                    chatStats.value = null  // Reset stats when changing chat
                    await loadMessages()
                    await loadChatStats(chat.id)  // Load stats for this chat
                    await nextTick()
                    scrollToBottom()
                    // Start auto-refresh for new messages
                    startMessageRefresh()
                }
                
                // Auto-refresh messages every 3 seconds to catch new messages
                const startMessageRefresh = () => {
                    stopMessageRefresh()  // Clear any existing timer
                    messageRefreshTimer = setInterval(async () => {
                        if (!selectedChat.value || loading.value) return
                        await checkForNewMessages()
                    }, 3000)
                }
                
                const stopMessageRefresh = () => {
                    if (messageRefreshTimer) {
                        clearInterval(messageRefreshTimer)
                        messageRefreshTimer = null
                    }
                }
                
                // Check for new messages and deletions
                const checkForNewMessages = async () => {
                    if (!selectedChat.value) return
                    
                    try {
                        // Get latest messages (just first page)
                        const res = await fetch(`/api/chats/${selectedChat.value.id}/messages?limit=50&offset=0`, {
                            credentials: 'include'
                        })
                        if (!res.ok) return
                        
                        const latestMessages = await res.json()
                        const latestIds = new Set(latestMessages.map(m => m.id))
                        const existingIds = new Set(messages.value.map(m => m.id))
                        
                        // Find new messages (in server response but not in our view)
                        const newMessages = latestMessages.filter(m => !existingIds.has(m.id))
                        
                        // Find deleted messages - ONLY check messages that overlap with our fetch
                        // We fetched the latest 50/20 from server. Compare with our newest messages.
                        // Sort our messages by date descending to get the newest ones
                        const sortedByDate = [...messages.value].sort((a, b) => 
                            new Date(b.date) - new Date(a.date)
                        )
                        // Get our newest messages (same count as server returned)
                        const ourNewestMessages = sortedByDate.slice(0, latestMessages.length)
                        
                        // Only messages that SHOULD be in the latest fetch but aren't = deleted
                        // A message is deleted if: it's in our newest messages AND not in server's latest
                        const deletedIds = ourNewestMessages
                            .filter(m => !latestIds.has(m.id))
                            .map(m => m.id)
                        
                        // Remove deleted messages
                        if (deletedIds.length > 0) {
                            const deletedSet = new Set(deletedIds)
                            messages.value = messages.value.filter(m => !deletedSet.has(m.id))
                            console.log(`[Auto-refresh] Removed ${deletedIds.length} deleted message(s)`)
                        }
                        
                        // Add new messages
                        if (newMessages.length > 0) {
                            messages.value.push(...newMessages)
                            console.log(`[Auto-refresh] Added ${newMessages.length} new message(s)`)
                            
                            // Scroll to bottom if user is near bottom
                            await nextTick()
                            const container = messagesContainer.value
                            if (container) {
                                const isNearBottom = container.scrollTop + container.clientHeight >= container.scrollHeight - 200
                                if (isNearBottom) {
                                    scrollToBottom()
                                }
                            }
                        }
                    } catch (e) {
                        console.warn('[Auto-refresh] Error checking for messages:', e)
                    }
                }

                const loadMessages = async () => {
                    if (loading.value || !hasMore.value || !selectedChat.value) return

                    loading.value = true
                    try {
                        const limit = 50
                        let url = `/api/chats/${selectedChat.value.id}/messages?limit=${limit}`

                        // Use cursor-based pagination (faster) instead of offset
                        // For initial load or search, don't use cursor
                        // For subsequent loads, use the oldest message's date as cursor
                        if (messages.value.length > 0 && !messageSearchQuery.value) {
                            // Find the oldest message (messages are sorted newest first)
                            const oldestMsg = messages.value.reduce((oldest, msg) => {
                                const msgDate = new Date(msg.date)
                                const oldestDate = new Date(oldest.date)
                                return msgDate < oldestDate ? msg : oldest
                            }, messages.value[0])
                            
                            if (oldestMsg?.date) {
                                url += `&before_date=${encodeURIComponent(oldestMsg.date)}`
                                if (oldestMsg.id) {
                                    url += `&before_id=${oldestMsg.id}`
                                }
                            }
                        }

                        if (messageSearchQuery.value) {
                            // Search still uses offset for simplicity
                            const offset = page.value * limit
                            url = `/api/chats/${selectedChat.value.id}/messages?limit=${limit}&offset=${offset}`
                            url += `&search=${encodeURIComponent(messageSearchQuery.value)}`
                        }

                        const res = await fetch(url, {
                            credentials: 'include'
                        })
                        const newMessages = await res.json()

                        if (newMessages.length < limit) {
                            hasMore.value = false
                        }

                        // Merge new messages, preferring complete messages from pagination over
                        // incomplete jumpToDate messages (which lack user info, reactions, etc.)
                        const existingById = new Map(messages.value.map(m => [m.id, m]))
                        for (const newMsg of newMessages) {
                            // Prefer new messages (from pagination with joins) over existing ones
                            existingById.set(newMsg.id, newMsg)
                        }
                        messages.value = Array.from(existingById.values())
                        page.value++  // Still increment for search pagination
                    } catch (e) {
                        console.error("Failed to load messages", e)
                    } finally {
                        loading.value = false
                    }
                }

                const searchMessages = async () => {
                    messages.value = []
                    page.value = 0
                    hasMore.value = true
                    await loadMessages()
                }

                const handleScroll = (e) => {
                    const { scrollTop, scrollHeight, clientHeight } = e.target
                    // Load more when scrolling near top (for older messages)
                    if (scrollTop < 100 && !loading.value && hasMore.value) {
                        const previousHeight = scrollHeight
                        loadMessages().then(() => {
                            // Maintain scroll position
                            nextTick(() => {
                                const newHeight = messagesContainer.value.scrollHeight
                                messagesContainer.value.scrollTop = scrollTop + (newHeight - previousHeight)
                            })
                        })
                    }
                    
                    // Show/hide scroll to bottom button
                    // Show when scrolled more than 300px from bottom
                    const distanceFromBottom = scrollHeight - scrollTop - clientHeight
                    showScrollToBottom.value = distanceFromBottom > 300
                }

                const scrollToBottom = () => {
                    if (messagesContainer.value) {
                        messagesContainer.value.scrollTop = messagesContainer.value.scrollHeight
                    }
                }

                const scrollToLatest = () => {
                    scrollToBottom()
                    showScrollToBottom.value = false
                }

                const isOwnMessage = (msg) => {
                    // Check explicit flag first (available in v2.0+)
                    if (msg.is_outgoing !== undefined && msg.is_outgoing !== null) {
                        return msg.is_outgoing === 1
                    }

                    // Fallback for private chats (legacy)
                    if (selectedChat.value.type === 'private') {
                        return msg.sender_id !== selectedChat.value.id
                    }
                    // In groups/channels: we can't easily know without "me" ID or is_outgoing flag
                    return false
                }

                const getSenderName = (msg) => {
                    if (msg.first_name || msg.last_name) {
                        return `${msg.first_name || ''} ${msg.last_name || ''}`.trim()
                    }
                    if (msg.username) return msg.username
                    if (msg.sender_id) return `User ${msg.sender_id}`
                    return 'Deleted Account'
                }

                const isDeletedChat = (chat) => {
                    if (!chat) return false
                    const name = getChatName(chat)
                    return name === 'Deleted Account'
                }

                const isAudioFile = (msg) => {
                    // Check explicit media types from backend
                    if (msg.media_type === 'audio' || msg.media_type === 'voice') return true
                    // Check mime type (for older backups)
                    const mimeType = (msg.media_mime_type || '').toLowerCase()
                    if (mimeType.startsWith('audio/')) return true
                    // Check file extension as last resort
                    const filename = getDocumentDisplayName(msg).toLowerCase()
                    return filename.endsWith('.ogg') || filename.endsWith('.mp3') ||
                        filename.endsWith('.wav') || filename.endsWith('.m4a') ||
                        filename.endsWith('.opus') || filename.endsWith('.flac')
                }

                const exportChat = () => {
                    if (!selectedChat.value) return
                    const url = `/api/chats/${selectedChat.value.id}/export`
                    window.open(url, '_blank')
                }

                const showSenderName = (index) => {
                    if (index === 0) return true
                    const prevMsg = sortedMessages.value[index - 1]
                    const currMsg = sortedMessages.value[index]
                    return prevMsg.sender_id !== currMsg.sender_id
                }

                const showDateSeparator = (index) => {
                    if (index === 0) return true
                    const prevMsg = sortedMessages.value[index - 1]
                    const currMsg = sortedMessages.value[index]
                    return moment(prevMsg.date).format('YYYY-MM-DD') !== moment(currMsg.date).format('YYYY-MM-DD')
                }

                const getChatName = (chat) => {
                    if (chat.title) return chat.title
                    const firstName = chat.first_name || ''
                    const lastName = chat.last_name || ''
                    const name = `${firstName} ${lastName}`.trim()
                    return name || chat.username || 'Deleted Account'
                }

                const getInitials = (chat) => {
                    const name = getChatName(chat)
                    return name.split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase()
                }

                const getSenderColor = (msg) => {
                    // Use sender_id when available, otherwise fall back to chat_id
                    const id = msg.sender_id ?? msg.chat_id ?? 0

                    // Simple hash function for better color distribution
                    let hash = 0
                    const idStr = String(id)
                    for (let i = 0; i < idStr.length; i++) {
                        hash = ((hash << 5) - hash) + idStr.charCodeAt(i)
                        hash = hash & hash // Convert to 32-bit integer
                    }

                    // Generate hue from hash for diverse name colors
                    const hue = Math.abs(hash) % 360
                    return hue
                }

                // Get background color for message bubble
                const getMessageBackground = (msg) => {
                    const isOwn = isOwnMessage(msg)

                    if (isOwn) {
                        // Own messages: Strong blue background
                        return 'hsla(210, 60%, 28%, 0.95)'
                    } else {
                        // Others: Unified softer gray background
                        return 'hsla(220, 20%, 25%, 0.80)'
                    }
                }

                // Get color for sender name (unique per person)
                const getSenderNameColor = (msg) => {
                    const hue = getSenderColor(msg)
                    // Bright, vibrant color for name
                    return `hsl(${hue}, 70%, 65%)`
                }

                const getPollPercentage = (msg, answer) => {
                    const results = msg.raw_data?.poll?.results
                    if (!results || !results.total_voters) return 0

                    const res = results.results?.find(r => r.option === answer.option)
                    if (!res) return 0

                    return Math.round((res.voters / results.total_voters) * 100)
                }

                const getSenderStyle = (msg) => {
                    return {
                        backgroundColor: getMessageBackground(msg),
                    }
                }

                const formatDate = (dateStr) => {
                    if (!dateStr) return ''
                    const date = moment(dateStr)
                    if (date.isSame(moment(), 'day')) return 'Today'
                    if (date.isSame(moment().subtract(1, 'day'), 'day')) return 'Yesterday'
                    return date.format('MMM D')
                }

                const formatDateFull = (dateStr) => {
                    return moment(dateStr).format('MMMM D, YYYY')
                }

                const formatTime = (dateStr) => {
                    return moment(dateStr).format('HH:mm')
                }

                const formatReactionEmoji = (emoji) => {
                    // Handle custom emojis (stored as custom_documentId)
                    if (emoji && emoji.startsWith('custom_')) {
                        // For custom emojis, show a placeholder or try to extract emoji
                        // In the future, we could load the actual sticker/emoji
                        return 'üé≠'
                    }
                    return emoji || 'üëç'
                }

                const formatLastBackupTime = (timeStr, tz, timeSource) => {
                    if (!timeStr) {
                        return 'Never'
                    }
                    
                    try {
                        // Ensure timezone is valid, fallback to Europe/Madrid
                        const timezone = tz && moment.tz.zone(tz) ? tz : 'Europe/Madrid'
                        
                        // Always convert to the configured timezone
                        // Metadata stores UTC (with Z), sync_status might be UTC or server local
                        // To be safe, we'll try to detect and convert appropriately
                        let parsedMoment
                        if (timeStr.endsWith('Z') || (timeStr.includes('T') && timeStr.includes('Z'))) {
                            // UTC ISO format (from metadata) - definitely UTC
                            parsedMoment = moment.utc(timeStr).tz(timezone)
                        } else if (timeStr.includes('T')) {
                            // ISO format without Z - assume UTC and convert
                            parsedMoment = moment.utc(timeStr).tz(timezone)
                        } else {
                            // SQLite timestamp format (YYYY-MM-DD HH:mm:ss)
                            // The issue: SQLite CURRENT_TIMESTAMP might be UTC or server local
                            // Best approach: Always treat as UTC if from sync_status (Docker containers often run in UTC)
                            // Then convert to configured timezone
                            if (timeSource === 'sync_status') {
                                // Treat as UTC and convert to configured timezone
                                // This handles both cases: if it's actually UTC, it's correct
                                // If it's server local but server is in UTC, it's also correct
                                parsedMoment = moment.utc(timeStr).tz(timezone)
                            } else {
                                // Unknown source, treat as UTC
                                parsedMoment = moment.utc(timeStr).tz(timezone)
                            }
                        }
                        
                        if (!parsedMoment.isValid()) {
                            console.error('Invalid date format:', timeStr)
                            return 'Unknown'
                        }
                        
                        // Get current time in the same timezone for comparison
                        const now = moment.tz(timezone)
                        
                        // Check if it's today
                        if (parsedMoment.isSame(now, 'day')) {
                            return `Today at ${parsedMoment.format('HH:mm')}`
                        }
                        // Check if it's yesterday
                        if (parsedMoment.isSame(now.clone().subtract(1, 'day'), 'day')) {
                            return `Yesterday at ${parsedMoment.format('HH:mm')}`
                        }
                        // Otherwise show date and time
                        return parsedMoment.format('MMM D, YYYY [at] HH:mm')
                    } catch (e) {
                        console.error('Error formatting last backup time:', e, timeStr, tz)
                        return 'Error'
                    }
                }

                const getMediaUrl = (msg) => {
                    if (!msg.media_path) return ''
                    // Extract folder and filename from the stored path
                    // media_path is like: /data/backups/media/35258041/filename.jpg
                    // We need to extract: /media/35258041/filename.jpg
                    const parts = msg.media_path.split(/[/\\]/)
                    const filename = parts.pop()
                    const folder = parts.pop()  // Get the folder from the path, not from chat_id
                    return `/media/${folder}/${filename}`
                }

                const getDocumentDisplayName = (msg) => {
                    // Prefer file name from media table when available
                    let name = msg.media_file_name || ''

                    // Fallback to filename from path
                    if (!name && msg.media_path) {
                        name = msg.media_path.split(/[/\\]/).pop()
                    }

                    if (!name) {
                        return 'document'
                    }

                    // Old backups may prefix message_id (e.g. 12345_original.png) ‚Äì strip that prefix
                    const withoutPrefix = name.replace(/^[0-9]+_/, '')
                    return withoutPrefix || name
                }

                const isImageDocument = (msg) => {
                    const name = (msg.media_file_name || msg.media_path || '').toString().toLowerCase()
                    const byExtension = ['.jpg', '.jpeg', '.png', '.gif', '.webp'].some(ext => name.endsWith(ext))

                    // As a secondary hint, use mime type if available
                    const mime = (msg.media_mime_type || '').toLowerCase()
                    const byMime = mime.startsWith('image/')

                    return byExtension || byMime
                }

                const handleImageError = (event, msg) => {
                    // Log the error for debugging (real 404s should be investigated)
                    console.error('Failed to load image:', getMediaUrl(msg))
                    // Show placeholder instead of broken image
                    const img = event.target
                    img.onerror = null  // Prevent infinite loop
                    img.src = 'data:image/svg+xml,' + encodeURIComponent(`
                        <svg xmlns="http://www.w3.org/2000/svg" width="200" height="150" viewBox="0 0 200 150">
                            <rect fill="#374151" width="200" height="150"/>
                            <text x="100" y="70" text-anchor="middle" fill="#9CA3AF" font-family="system-ui" font-size="12">Media not found</text>
                            <text x="100" y="90" text-anchor="middle" fill="#6B7280" font-family="system-ui" font-size="10">(file may be missing from disk)</text>
                        </svg>
                    `)
                    img.style.cursor = 'default'
                    img.onclick = null
                }
                
                const handleMediaError = (event, msg) => {
                    // Log the error for debugging (real 404s should be investigated)
                    console.error('Failed to load media:', getMediaUrl(msg))
                    // Replace with placeholder
                    const media = event.target
                    const parent = media.parentElement
                    if (parent) {
                        parent.innerHTML = `
                            <div class="flex items-center gap-2 text-gray-400 text-sm py-2">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                </svg>
                                <span>Media not found</span>
                            </div>
                        `
                    }
                }

                const openMedia = (msg) => {
                    window.open(getMediaUrl(msg), '_blank')
                }

                const linkifyText = (text) => {
                    if (!text) return ''
                    // Basic URL regex
                    const urlRegex = /(https?:\/\/[^\s]+)/g
                    return text.replace(urlRegex, '<a href="$1" target="_blank">$1</a>')
                }

                const scrollToMessage = (msgId) => {
                    // Find message element by ID and scroll to it
                    const msgIndex = sortedMessages.value.findIndex(m => m.id === msgId)
                    if (msgIndex !== -1) {
                        nextTick(() => {
                            const container = messagesContainer.value
                            const msgElements = container.querySelectorAll('.message-bubble')
                            if (msgElements[msgIndex]) {
                                msgElements[msgIndex].scrollIntoView({ behavior: 'smooth', block: 'center' })
                                // Highlight briefly
                                msgElements[msgIndex].style.backgroundColor = '#1e40af'
                                setTimeout(() => {
                                    msgElements[msgIndex].style.backgroundColor = ''
                                }, 1000)
                            }
                        })
                    } else {
                        console.log('Message not loaded yet')
                    }
                }

                const openDatePicker = (initialDate) => {
                    if (!selectedChat.value) return
                    
                    selectedDate.value = initialDate ? moment(initialDate).format('YYYY-MM-DD') : null
                    showDatePickerModal.value = true
                    
                    nextTick(() => {
                        if (datePickerInput.value && !flatpickrInstance) {
                            flatpickrInstance = flatpickr(datePickerInput.value, {
                                dateFormat: 'Y-m-d',
                                defaultDate: selectedDate.value || new Date(),
                                maxDate: 'today',
                                theme: 'dark',
                                onChange: (selectedDates, dateStr) => {
                                    selectedDate.value = dateStr
                                }
                            })
                        } else if (flatpickrInstance && selectedDate.value) {
                            flatpickrInstance.setDate(selectedDate.value, false)
                        }
                    })
                }

                const closeDatePicker = () => {
                    showDatePickerModal.value = false
                    if (flatpickrInstance) {
                        flatpickrInstance.destroy()
                        flatpickrInstance = null
                    }
                    selectedDate.value = null
                }

                const jumpToDate = async () => {
                    if (!selectedChat.value || !selectedDate.value) return
                    
                    // Capture chat ID to detect if user switches chats during async operations
                    const chatIdAtStart = selectedChat.value.id
                    
                    try {
                        // Fetch message for the selected date
                        // Pass timezone so backend can convert the displayed date to correct UTC bounds
                        const tz = encodeURIComponent(viewerTimezone.value)
                        const res = await fetch(
                            `/api/chats/${chatIdAtStart}/messages/by-date?date=${selectedDate.value}&timezone=${tz}`,
                            { credentials: 'include' }
                        )
                        
                        if (!res.ok) {
                            if (res.status === 404) {
                                closeDatePicker()
                                alert('No messages found for this date')
                                return
                            }
                            throw new Error('Failed to find message')
                        }
                        
                        const message = await res.json()
                        closeDatePicker()
                        
                        // Abort if user switched chats while waiting for response
                        if (!selectedChat.value || selectedChat.value.id !== chatIdAtStart) {
                            return
                        }
                        
                        // Check if message is already loaded
                        const existingIndex = sortedMessages.value.findIndex(m => m.id === message.id)
                        
                        if (existingIndex !== -1) {
                            // Message already loaded, just scroll to it
                            await nextTick()
                            scrollToMessage(message.id)
                        } else {
                            // Message not loaded, we need to load it
                            // Since messages are loaded in DESC order (newest first), and we're looking for
                            // a specific date, we'll add the message to our list and scroll to it
                            // The message will be properly positioned when we load more messages
                            
                            // Capture oldest loaded message date BEFORE adding the new message
                            // Store as ISO string to avoid any reactivity issues with moment objects
                            const oldestLoadedDateBeforeJump = sortedMessages.value.length > 0 
                                ? sortedMessages.value[0].date 
                                : null
                            
                            // Add the message to the list (it will be sorted correctly by date)
                            messages.value.push(message)
                            
                            await nextTick()
                            
                            // Find it in sorted messages and scroll
                            const sortedIndex = sortedMessages.value.findIndex(m => m.id === message.id)
                            if (sortedIndex !== -1) {
                                scrollToMessage(message.id)
                                
                                // Load surrounding messages to fill the gap between jumped message
                                // and previously loaded messages. loadMessages() uses pagination,
                                // so we need to keep loading until the gap is filled.
                                const targetDate = moment(message.date)
                                
                                // Only fill gap if target is older than what we had loaded
                                if (oldestLoadedDateBeforeJump && targetDate.isBefore(moment(oldestLoadedDateBeforeJump))) {
                                    // Load messages in background to fill the gap
                                    const fillGap = async () => {
                                        // Keep loading until pagination catches up to the target date
                                        let iterations = 0
                                        const maxIterations = 20 // Safety limit
                                        const targetTime = new Date(message.date).getTime()
                                        
                                        while (hasMore.value && iterations < maxIterations) {
                                            // Abort if user switched to a different chat
                                            if (!selectedChat.value || selectedChat.value.id !== chatIdAtStart) {
                                                return
                                            }
                                            
                                            // Check if gap is filled by looking at target's position
                                            // in sorted messages (oldest first)
                                            const sorted = sortedMessages.value
                                            const targetIdx = sorted.findIndex(m => m.id === message.id)
                                            
                                            // Gap is filled when target is no longer the oldest
                                            // (pagination loaded older messages)
                                            if (targetIdx > 0) {
                                                break
                                            }
                                            
                                            // Track message IDs before loading to detect new messages
                                            const idsBefore = new Set(messages.value.map(m => m.id))
                                            
                                            await loadMessages()
                                            iterations++
                                            
                                            // Check if any newly loaded message is at or before target date
                                            // This means pagination has reached the target (gap is filled)
                                            // without needing to load messages OLDER than the target
                                            let reachedTarget = false
                                            for (const m of messages.value) {
                                                if (!idsBefore.has(m.id) && new Date(m.date).getTime() <= targetTime) {
                                                    reachedTarget = true
                                                    break
                                                }
                                            }
                                            if (reachedTarget) {
                                                break
                                            }
                                            
                                            // Small delay between requests
                                            await new Promise(resolve => setTimeout(resolve, 50))
                                        }
                                    }
                                    
                                    // Start filling gap after a short delay
                                    setTimeout(fillGap, 200)
                                }
                            }
                        }
                    } catch (e) {
                        console.error('Error jumping to date:', e)
                        closeDatePicker()
                        alert('Failed to jump to date. Please try again.')
                    }
                }

                return {
                    chats,
                    filteredChats,
                    selectedChat,
                    messages,
                    sortedMessages,
                    searchQuery,
                    messageSearchQuery,
                    loading,
                    isGroup,
                    selectChat,
                    chatStats,
                    searchMessages,
                    isOwnMessage,
                    getSenderName,
                    showSenderName,
                    showDateSeparator,
                    // Album support
                    getAlbumForMessage,
                    isFirstInAlbum,
                    isHiddenAlbumMessage,
                    getAlbumGridClass,
                    getChatName,
                    getInitials,
                    formatDate,
                    formatDateFull,
                    formatTime,
                    formatLastBackupTime,
                    formatReactionEmoji,
                    getMediaUrl,
                    getDocumentDisplayName,
                    isImageDocument,
                    handleImageError,
                    handleMediaError,
                    openMedia,
                    linkifyText,
                    scrollToMessage,
                    messagesContainer,
                    scrollAnchor,
                    handleScroll,
                    // Auth
                    isAuthenticated,
                    authRequired,
                    authCheckFailed,
                    loadingAuth,
                    loginForm,
                    loginError,
                    performLogin,
                    // Colors / avatars
                    getSenderStyle,
                    getSenderNameColor,
                    getPollPercentage,
                    isDeletedChat,
                    isAudioFile,
                    exportChat,
                    // Error states
                    chatsError,
                    loadChats,
                    loadMoreChats,
                    // Chat pagination
                    chatOffset,
                    chatTotal,
                    hasMoreChats,
                    loadingMoreChats,
                    infiniteScrollSentinel,
                    // Search
                    searchResults,
                    searchLoading,
                    onSearchInput,
                    // Loading states
                    loadingChats,
                    loadingStats,
                    // Stats
                    statsData,
                    statsPopupOpen,
                    showStatsUI,
                    formatStatsTime,
                    formatNumber,
                    formatSize,
                    lastBackupTime,
                    lastBackupTimeSource,
                    listenerActive,
                    viewerTimezone,
                    // Date picker
                    showDatePickerModal,
                    datePickerInput,
                    openDatePicker,
                    closeDatePicker,
                    jumpToDate,
                    // Scroll to bottom
                    showScrollToBottom,
                    scrollToLatest,
                    // Notifications (v5.0)
                    notificationsEnabled,
                    notificationsSupported,
                    notificationPermission,
                    pushEnabled,
                    pushSubscribed,
                    requestNotificationPermission,
                    subscribeToPush,
                    unsubscribeFromPush,
                }
            }
        }).mount('#app')
    </script>
</body>

</html>